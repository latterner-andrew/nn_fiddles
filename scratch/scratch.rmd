---
title: "scratch"
author: "[tim leffel](http://lefft.xyz) /// last update: ``r Sys.Date()``"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=FALSE)
```


### Linear algebra refresher notes 

#### operations between matrix `x` and vector `y` 
```{r}
# exx use just ints 1,...,5
set.seed(69)
vals <- 0L:9L 
sampv <- function(n){ sample(vals, size=n, replace=TRUE) }


# dims for matrix x and vector y 
shx <- c(4, 3)
shy <- c(3)

# generate x and y 
(x <- matrix(data=sampv(n=prod(shx)), nrow=shx[1], ncol=shx[2])) 
(y <- sampv(n=prod(shy))) 

# dot prod shd have shape (4) v vals (52, 79, 64, 89)   [for exx, see: ?`%*%`] 
(x %*% y)
```


#### operations between matrices `x1`, `x2` with same shapes 
```{r}
x1 <- ''
```


#### operations between matrices `x1`, `x2` with different shapes 
```{r}

```



#### higher-order arrays with matching shapes 
```{r}
sha <- c(4, 3, 2)
(a1 <- array(sampv(prod(sha)), dim=sha))
(a2 <- array(sampv(prod(sha)), dim=sha))

# dot prod of two 3d arrays 
(a1 %*% a2)

# just sums up elements matching elements from each sample dim element (final)
# or: `p <- 0; for (idx in 1:24){ p <- p + (a1[idx] * a2[idx]) }; p`
sum(sapply(1:24, function(idx) (a1[idx] * a2[idx])))
```


... then w same ndims but diff dim lengths/sizes
... then w diff ndims (e.g. what constraints do we need??) 


#### geometric interp of tensor ops, book sec2.3.5, pp43-44 
```{r}
lefftpack::lazy_setup()

(d <- tibble(id=c('o','a','b','a+b'), x=c(0, .5, 1, 1.5), y=c(0, 1, .25, 1.25)))
# matrix(c(.5,1,  1,.25), ncol=2, byrow=TRUE)

pad <- .05

d %>% 
  ggplot(aes(x=x, y=y, label=id, color=id)) + 
  coord_fixed(xlim=c(-1,2), ylim=c(-1,2)) + 
  geom_vline(aes(xintercept=0)) + geom_hline(aes(yintercept=0)) + 
  labs(subtitle="geometric interp of vector ops",
       caption="ex from book sec2.3.5, pp43-44") + 
  geom_label(show.legend=FALSE) + 
  geom_segment(data=NULL, aes(x=0+pad, y=0+pad, xend=.5-pad, yend=1-pad), 
               color="black", arrow=arrow(), alpha=.1) + 
  geom_segment(data=NULL, aes(x=0+pad, y=0+pad, xend=1-pad, yend=.25-pad), 
               color="black", arrow=arrow(), alpha=.1)

```





### misc fiddling

```{r}
### from keras activation funcs docs: https://keras.io/activations/

# regular/smooth sigmoid activation function: 
sig <- function(x){
  return(1 / (1 + exp(-x)))
}
# Hard sigmoid activation:
#   >> 0 if x < -2.5
#   >> 1 if x > 2.5
#   >> 0.2 * x + 0.5 if -2.5 <= x <= 2.5.
# or to be clever/obscure: if (abs(x) > 2.5) as.numeric(x > 0) else (x*.2)+.5 
# or can widen by using bounds (-5, 5), with *.1 slope 
hsig <- function(x){
  if (x < -2.5) return(0)
  if (x >  2.5) return(1)
  return((x * .2) + .5)
}
# plot them against each other 
plot(Vectorize(sig), from=-5, to=5, col='red')
plot(Vectorize(hsig), from=-5, to=5, col='blue', add=TRUE)


par(mfrow=c(3,2))
plot(function(x) exp(x), from=-5, to=5, main='exp(x)')
plot(function(x) exp(-x), from=-5, to=5, main='exp(-x)')
plot(function(x) 1+exp(-x), from=-5, to=5, main='1 + exp(-x)')
plot(function(x) 1/exp(-x), from=-5, to=5, main='1 / exp(-x)')
plot(function(x) 1/(1+exp(-x)),from=-5,to=5,col='blue',main='1 / (1 + exp(-x))')
plot(function(x) 1/(-1+exp(-x)), from=-5, to=5, main='1 / (-1 + exp(-x))')
par(mfrow=c(1,1))

par(mfrow=c(2,2))
plot(sig, from=-5, to=5, main='sigmoid')
plot(Vectorize(hsig), from=-5, to=5, main='hard sigmoid')
plot(tanh, from=-5, to=5, main='tanh (hyperbolic tangent)')
plot(tan, from=-5, to=5, main='tan')

par(mfrow=c(1,3))
plot(tan, from=-5, to=5, main='tan')
plot(atan, from=-5, to=5, main='atan')
plot(tanh, from=-5, to=5, main='tanh', col='blue')
par(mfrow=c(1,1))


# plot(tanpi, from=-5, to=5, main='tanpi')
# plot(atanh, from=-5, to=5, main='atanh')
# 
# The arc-tangent of two arguments atan2(y, x) returns the angle between the
# x-axis and the vector from the origin to (x, y), i.e., for positive arguments
# atan2(y, x) == atan(y/x).
```

